// Code generated by ros-gen-go.
// source: /opt/ros/jade/share/ros/../control_msgs/msg//JointTolerance.msg
// DO NOT EDIT!
package control_msgs

type _MsgJointTolerance struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgJointTolerance) Text() string {
	return t.text
}

func (t *_MsgJointTolerance) Name() string {
	return t.name
}

func (t *_MsgJointTolerance) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgJointTolerance) NewMessage() ros.Message {
	m := new(JointTolerance)

	return m
}

var (
	MsgJointTolerance = &_MsgJointTolerance{
		`# The tolerances specify the amount the position, velocity, and
# accelerations can vary from the setpoints.  For example, in the case
# of trajectory control, when the actual position varies beyond
# (desired position + position tolerance), the trajectory goal may
# abort.
# 
# There are two special values for tolerances:
#  * 0 - The tolerance is unspecified and will remain at whatever the default is
#  * -1 - The tolerance is "erased".  If there was a default, the joint will be
#         allowed to move without restriction.

string name
float64 position  # in radians or meters (for a revolute or prismatic joint, respectively)
float64 velocity  # in rad/sec or m/sec
float64 acceleration  # in rad/sec^2 or m/sec^2
`,
		"control_msgs/JointTolerance",
		"497c854e94a0a8974a8f8944087809db",
	}
)

type JointTolerance struct {
	Name         string
	Position     float64
	Velocity     float64
	Acceleration float64
}

func (m *JointTolerance) Type() ros.MessageType {
	return MsgJointTolerance
}

func (m *JointTolerance) Serialize(buf *bytes.Buffer) (err error) {
	// Name
	binary.Write(buf, binary.LittleEndian, uint32(len([]byte(m.Name))))
	buf.Write([]byte(m.Name))

	// Position
	binary.Write(buf, binary.LittleEndian, m.Position)

	// Velocity
	binary.Write(buf, binary.LittleEndian, m.Velocity)

	// Acceleration
	binary.Write(buf, binary.LittleEndian, m.Acceleration)

	return
}

func (m *String) Deserialize(buf *bytes.Reader) (err error) {
	// Name
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	data := make([]byte, int(size))
	if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
		return err
	}
	m.Name = string(data)

	// Position
	if err = binary.Read(buf, binary.LittleEndian, &m.Position); err != nil {
		return err
	}

	// Velocity
	if err = binary.Read(buf, binary.LittleEndian, &m.Velocity); err != nil {
		return err
	}

	// Acceleration
	if err = binary.Read(buf, binary.LittleEndian, &m.Acceleration); err != nil {
		return err
	}

	return
}
