// Code generated by ros-gen-go.
// source: /opt/ros/jade/share/ros/../sensor_msgs/msg//JoyFeedback.msg
// DO NOT EDIT!
package sensor_msgs

type _MsgJoyFeedback struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgJoyFeedback) Text() string {
	return t.text
}

func (t *_MsgJoyFeedback) Name() string {
	return t.name
}

func (t *_MsgJoyFeedback) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgJoyFeedback) NewMessage() ros.Message {
	m := new(JoyFeedback)

	return m
}

var (
	MsgJoyFeedback = &_MsgJoyFeedback{
		`# Declare of the type of feedback
uint8 TYPE_LED    = 0
uint8 TYPE_RUMBLE = 1
uint8 TYPE_BUZZER = 2

uint8 type

# This will hold an id number for each type of each feedback.
# Example, the first led would be id=0, the second would be id=1
uint8 id

# Intensity of the feedback, from 0.0 to 1.0, inclusive.  If device is
# actually binary, driver should treat 0<=x<0.5 as off, 0.5<=x<=1 as on.
float32 intensity

`,
		"sensor_msgs/JoyFeedback",
		"6a3facdc77535982cb1741407e0f8e73",
	}
)

type JoyFeedback struct {
	Type      uint8
	ID        uint8
	Intensity float32
}

func (m *JoyFeedback) Type() ros.MessageType {
	return MsgJoyFeedback
}

func (m *JoyFeedback) Serialize(buf *bytes.Buffer) (err error) {
	// Type
	binary.Write(buf, binary.LittleEndian, m.Type)

	// ID
	binary.Write(buf, binary.LittleEndian, m.ID)

	// Intensity
	binary.Write(buf, binary.LittleEndian, m.Intensity)

	return
}

func (m *String) Deserialize(buf *bytes.Reader) (err error) {
	// Type
	if err = binary.Read(buf, binary.LittleEndian, &m.Type); err != nil {
		return err
	}

	// ID
	if err = binary.Read(buf, binary.LittleEndian, &m.ID); err != nil {
		return err
	}

	// Intensity
	if err = binary.Read(buf, binary.LittleEndian, &m.Intensity); err != nil {
		return err
	}

	return
}
