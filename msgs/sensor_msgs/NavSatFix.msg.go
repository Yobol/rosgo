// Code generated by ros-gen-go.
// source: /opt/ros/jade/share/ros/../sensor_msgs/msg//NavSatFix.msg
// DO NOT EDIT!
package sensor_msgs

type _MsgNavSatFix struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgNavSatFix) Text() string {
	return t.text
}

func (t *_MsgNavSatFix) Name() string {
	return t.name
}

func (t *_MsgNavSatFix) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgNavSatFix) NewMessage() ros.Message {
	m := new(NavSatFix)

	return m
}

var (
	MsgNavSatFix = &_MsgNavSatFix{
		`# Navigation Satellite fix for any Global Navigation Satellite System
#
# Specified using the WGS 84 reference ellipsoid

# header.stamp specifies the ROS time for this measurement (the
#        corresponding satellite time may be reported using the
#        sensor_msgs/TimeReference message).
#
# header.frame_id is the frame of reference reported by the satellite
#        receiver, usually the location of the antenna.  This is a
#        Euclidean frame relative to the vehicle, not a reference
#        ellipsoid.
Header header

# satellite fix status information
NavSatStatus status

# Latitude [degrees]. Positive is north of equator; negative is south.
float64 latitude

# Longitude [degrees]. Positive is east of prime meridian; negative is west.
float64 longitude

# Altitude [m]. Positive is above the WGS 84 ellipsoid
# (quiet NaN if no altitude is available).
float64 altitude

# Position covariance [m^2] defined relative to a tangential plane
# through the reported position. The components are East, North, and
# Up (ENU), in row-major order.
#
# Beware: this coordinate system exhibits singularities at the poles.

float64[9] position_covariance

# If the covariance of the fix is known, fill it in completely. If the
# GPS receiver provides the variance of each measurement, put them
# along the diagonal. If only Dilution of Precision is available,
# estimate an approximate covariance from that.

uint8 COVARIANCE_TYPE_UNKNOWN = 0
uint8 COVARIANCE_TYPE_APPROXIMATED = 1
uint8 COVARIANCE_TYPE_DIAGONAL_KNOWN = 2
uint8 COVARIANCE_TYPE_KNOWN = 3

uint8 position_covariance_type
`,
		"sensor_msgs/NavSatFix",
		"5759544745c46283e170f1993e43802f",
	}
)

type NavSatFix struct {
	Header                 Header
	Status                 NavSatStatus
	Latitude               float64
	Longitude              float64
	Altitude               float64
	PositionCovariance     [9]float64
	PositionCovarianceType uint8
}

func (m *NavSatFix) Type() ros.MessageType {
	return MsgNavSatFix
}

func (m *NavSatFix) Serialize(buf *bytes.Buffer) (err error) {
	// Header
	if err = m.Header.Serialize(buf); err != nil {
		return err
	}

	// Status
	if err = m.Status.Serialize(buf); err != nil {
		return err
	}

	// Latitude
	binary.Write(buf, binary.LittleEndian, m.Latitude)

	// Longitude
	binary.Write(buf, binary.LittleEndian, m.Longitude)

	// Altitude
	binary.Write(buf, binary.LittleEndian, m.Altitude)

	// PositionCovariance
	binary.Write(buf, binary.LittleEndian, uint32(len(m.PositionCovariance)))
	for _, e := range m.PositionCovariance {
		binary.Write(buf, binary.LittleEndian, e)
	}

	// PositionCovarianceType
	binary.Write(buf, binary.LittleEndian, m.PositionCovarianceType)

	return
}

func (m *String) Deserialize(buf *bytes.Reader) (err error) {
	// Header
	if err = m.Header.Deserialize(buf); err != nil {
		return err
	}

	// Status
	if err = m.Status.Deserialize(buf); err != nil {
		return err
	}

	// Latitude
	if err = binary.Read(buf, binary.LittleEndian, &m.Latitude); err != nil {
		return err
	}

	// Longitude
	if err = binary.Read(buf, binary.LittleEndian, &m.Longitude); err != nil {
		return err
	}

	// Altitude
	if err = binary.Read(buf, binary.LittleEndian, &m.Altitude); err != nil {
		return err
	}

	// PositionCovariance
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	if size > 9 {
		return fmt.Errorf("array size for PositionCovariance too large: expected=9, got=%d", size)
	}
	for i := 0; i < int(size); i++ {
		if err = binary.Read(buf, binary.LittleEndian, &m.PositionCovariance[i]); err != nil {
			return err
		}
	}

	// PositionCovarianceType
	if err = binary.Read(buf, binary.LittleEndian, &m.PositionCovarianceType); err != nil {
		return err
	}

	return
}
