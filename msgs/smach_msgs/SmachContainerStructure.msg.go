// Code generated by ros-gen-go.
// source: /opt/ros/jade/share/ros/../smach_msgs/msg//SmachContainerStructure.msg
// DO NOT EDIT!
package smach_msgs

type _MsgSmachContainerStructure struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgSmachContainerStructure) Text() string {
	return t.text
}

func (t *_MsgSmachContainerStructure) Name() string {
	return t.name
}

func (t *_MsgSmachContainerStructure) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgSmachContainerStructure) NewMessage() ros.Message {
	m := new(SmachContainerStructure)

	return m
}

var (
	MsgSmachContainerStructure = &_MsgSmachContainerStructure{
		`Header header

# The path to this node in the server
string path

# The children of this node
string[] children

# The outcome edges
# Each index across these arrays denote one edge
string[] internal_outcomes
string[] outcomes_from
string[] outcomes_to

# The potential outcomes from this container
string[] container_outcomes
`,
		"smach_msgs/SmachContainerStructure",
		"01c82f66ac449a8d875e9aebdab7682e",
	}
)

type SmachContainerStructure struct {
	Header            Header
	Path              string
	Children          []string
	InternalOutcomes  []string
	OutcomesFrom      []string
	OutcomesTo        []string
	ContainerOutcomes []string
}

func (m *SmachContainerStructure) Type() ros.MessageType {
	return MsgSmachContainerStructure
}

func (m *SmachContainerStructure) Serialize(buf *bytes.Buffer) (err error) {
	// Header
	if err = m.Header.Serialize(buf); err != nil {
		return err
	}

	// Path
	binary.Write(buf, binary.LittleEndian, uint32(len([]byte(m.Path))))
	buf.Write([]byte(m.Path))

	// Children
	binary.Write(buf, binary.LittleEndian, uint32(len(m.Children)))
	for _, e := range m.Children {
		binary.Write(buf, binary.LittleEndian, uint32(len([]byte(e))))
		buf.Write([]byte(e))
	}

	// InternalOutcomes
	binary.Write(buf, binary.LittleEndian, uint32(len(m.InternalOutcomes)))
	for _, e := range m.InternalOutcomes {
		binary.Write(buf, binary.LittleEndian, uint32(len([]byte(e))))
		buf.Write([]byte(e))
	}

	// OutcomesFrom
	binary.Write(buf, binary.LittleEndian, uint32(len(m.OutcomesFrom)))
	for _, e := range m.OutcomesFrom {
		binary.Write(buf, binary.LittleEndian, uint32(len([]byte(e))))
		buf.Write([]byte(e))
	}

	// OutcomesTo
	binary.Write(buf, binary.LittleEndian, uint32(len(m.OutcomesTo)))
	for _, e := range m.OutcomesTo {
		binary.Write(buf, binary.LittleEndian, uint32(len([]byte(e))))
		buf.Write([]byte(e))
	}

	// ContainerOutcomes
	binary.Write(buf, binary.LittleEndian, uint32(len(m.ContainerOutcomes)))
	for _, e := range m.ContainerOutcomes {
		binary.Write(buf, binary.LittleEndian, uint32(len([]byte(e))))
		buf.Write([]byte(e))
	}

	return
}

func (m *String) Deserialize(buf *bytes.Reader) (err error) {
	// Header
	if err = m.Header.Deserialize(buf); err != nil {
		return err
	}

	// Path
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	data := make([]byte, int(size))
	if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
		return err
	}
	m.Path = string(data)

	// Children
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	m.Children = make([]string, int(size))
	for i := 0; i < int(size); i++ {
		var size uint32
		if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
			return err
		}
		data := make([]byte, int(size))
		if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
			return err
		}
		m.Children[i] = string(data)
	}

	// InternalOutcomes
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	m.InternalOutcomes = make([]string, int(size))
	for i := 0; i < int(size); i++ {
		var size uint32
		if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
			return err
		}
		data := make([]byte, int(size))
		if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
			return err
		}
		m.InternalOutcomes[i] = string(data)
	}

	// OutcomesFrom
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	m.OutcomesFrom = make([]string, int(size))
	for i := 0; i < int(size); i++ {
		var size uint32
		if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
			return err
		}
		data := make([]byte, int(size))
		if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
			return err
		}
		m.OutcomesFrom[i] = string(data)
	}

	// OutcomesTo
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	m.OutcomesTo = make([]string, int(size))
	for i := 0; i < int(size); i++ {
		var size uint32
		if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
			return err
		}
		data := make([]byte, int(size))
		if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
			return err
		}
		m.OutcomesTo[i] = string(data)
	}

	// ContainerOutcomes
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	m.ContainerOutcomes = make([]string, int(size))
	for i := 0; i < int(size); i++ {
		var size uint32
		if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
			return err
		}
		data := make([]byte, int(size))
		if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
			return err
		}
		m.ContainerOutcomes[i] = string(data)
	}

	return
}
