// Code generated by ros-gen-go.
// source: /opt/ros/jade/share/ros/../trajectory_msgs/msg//JointTrajectoryPoint.msg
// DO NOT EDIT!
package trajectory_msgs

type _MsgJointTrajectoryPoint struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgJointTrajectoryPoint) Text() string {
	return t.text
}

func (t *_MsgJointTrajectoryPoint) Name() string {
	return t.name
}

func (t *_MsgJointTrajectoryPoint) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgJointTrajectoryPoint) NewMessage() ros.Message {
	m := new(JointTrajectoryPoint)

	return m
}

var (
	MsgJointTrajectoryPoint = &_MsgJointTrajectoryPoint{
		`# Each trajectory point specifies either positions[, velocities[, accelerations]]
# or positions[, effort] for the trajectory to be executed.
# All specified values are in the same order as the joint names in JointTrajectory.msg

float64[] positions
float64[] velocities
float64[] accelerations
float64[] effort
duration time_from_start
`,
		"trajectory_msgs/JointTrajectoryPoint",
		"0b7b3d8dcc88390331fe8287246f673f",
	}
)

type JointTrajectoryPoint struct {
	Positions     []float64
	Velocities    []float64
	Accelerations []float64
	Effort        []float64
	TimeFromStart ros.Duration
}

func (m *JointTrajectoryPoint) Type() ros.MessageType {
	return MsgJointTrajectoryPoint
}

func (m *JointTrajectoryPoint) Serialize(buf *bytes.Buffer) (err error) {
	// Positions
	binary.Write(buf, binary.LittleEndian, uint32(len(m.Positions)))
	for _, e := range m.Positions {
		binary.Write(buf, binary.LittleEndian, e)
	}

	// Velocities
	binary.Write(buf, binary.LittleEndian, uint32(len(m.Velocities)))
	for _, e := range m.Velocities {
		binary.Write(buf, binary.LittleEndian, e)
	}

	// Accelerations
	binary.Write(buf, binary.LittleEndian, uint32(len(m.Accelerations)))
	for _, e := range m.Accelerations {
		binary.Write(buf, binary.LittleEndian, e)
	}

	// Effort
	binary.Write(buf, binary.LittleEndian, uint32(len(m.Effort)))
	for _, e := range m.Effort {
		binary.Write(buf, binary.LittleEndian, e)
	}

	// TimeFromStart
	binary.Write(buf, binary.LittleEndian, m.TimeFromStart.Sec)
	binary.Write(buf, binary.LittleEndian, m.TimeFromStart.NSec)

	return
}

func (m *String) Deserialize(buf *bytes.Reader) (err error) {
	// Positions
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	m.Positions = make([]float64, int(size))
	for i := 0; i < int(size); i++ {
		if err = binary.Read(buf, binary.LittleEndian, &m.Positions[i]); err != nil {
			return err
		}
	}

	// Velocities
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	m.Velocities = make([]float64, int(size))
	for i := 0; i < int(size); i++ {
		if err = binary.Read(buf, binary.LittleEndian, &m.Velocities[i]); err != nil {
			return err
		}
	}

	// Accelerations
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	m.Accelerations = make([]float64, int(size))
	for i := 0; i < int(size); i++ {
		if err = binary.Read(buf, binary.LittleEndian, &m.Accelerations[i]); err != nil {
			return err
		}
	}

	// Effort
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	m.Effort = make([]float64, int(size))
	for i := 0; i < int(size); i++ {
		if err = binary.Read(buf, binary.LittleEndian, &m.Effort[i]); err != nil {
			return err
		}
	}

	// TimeFromStart
	if err = binary.Read(buf, binary.LittleEndian, &m.TimeFromStart.Sec); err != nil {
		return err
	}
	if err = binary.Read(buf, binary.LittleEndian, &m.TimeFromStart.NSec); err != nil {
		return err
	}

	return
}
