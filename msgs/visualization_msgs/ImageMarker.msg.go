// Code generated by ros-gen-go.
// source: /opt/ros/jade/share/ros/../visualization_msgs/msg//ImageMarker.msg
// DO NOT EDIT!
package visualization_msgs

type _MsgImageMarker struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgImageMarker) Text() string {
	return t.text
}

func (t *_MsgImageMarker) Name() string {
	return t.name
}

func (t *_MsgImageMarker) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgImageMarker) NewMessage() ros.Message {
	m := new(ImageMarker)

	return m
}

var (
	MsgImageMarker = &_MsgImageMarker{
		`uint8 CIRCLE=0
uint8 LINE_STRIP=1
uint8 LINE_LIST=2
uint8 POLYGON=3
uint8 POINTS=4

uint8 ADD=0
uint8 REMOVE=1

Header header
string ns		# namespace, used with id to form a unique id
int32 id          	# unique id within the namespace
int32 type        	# CIRCLE/LINE_STRIP/etc.
int32 action      	# ADD/REMOVE
geometry_msgs/Point position # 2D, in pixel-coords
float32 scale	 	# the diameter for a circle, etc.
std_msgs/ColorRGBA outline_color
uint8 filled		# whether to fill in the shape with color
std_msgs/ColorRGBA fill_color # color [0.0-1.0]
duration lifetime       # How long the object should last before being automatically deleted.  0 means forever


geometry_msgs/Point[] points # used for LINE_STRIP/LINE_LIST/POINTS/etc., 2D in pixel coords
std_msgs/ColorRGBA[] outline_colors # a color for each line, point, etc.`,
		"visualization_msgs/ImageMarker",
		"32f5635ee965c48f5d3f565629b204e2",
	}
)

type ImageMarker struct {
	Header        Header
	Ns            string
	ID            int32
	Type          int32
	Action        int32
	Position      geometry_msgs.Point
	Scale         float32
	OutlineColor  std_msgs.ColorRGBA
	Filled        uint8
	FillColor     std_msgs.ColorRGBA
	Lifetime      ros.Duration
	Points        []geometry_msgs.Point
	OutlineColors []std_msgs.ColorRGBA
}

func (m *ImageMarker) Type() ros.MessageType {
	return MsgImageMarker
}

func (m *ImageMarker) Serialize(buf *bytes.Buffer) (err error) {
	// Header
	if err = m.Header.Serialize(buf); err != nil {
		return err
	}

	// Ns
	binary.Write(buf, binary.LittleEndian, uint32(len([]byte(m.Ns))))
	buf.Write([]byte(m.Ns))

	// ID
	binary.Write(buf, binary.LittleEndian, m.ID)

	// Type
	binary.Write(buf, binary.LittleEndian, m.Type)

	// Action
	binary.Write(buf, binary.LittleEndian, m.Action)

	// Position
	if err = m.Position.Serialize(buf); err != nil {
		return err
	}

	// Scale
	binary.Write(buf, binary.LittleEndian, m.Scale)

	// OutlineColor
	if err = m.OutlineColor.Serialize(buf); err != nil {
		return err
	}

	// Filled
	binary.Write(buf, binary.LittleEndian, m.Filled)

	// FillColor
	if err = m.FillColor.Serialize(buf); err != nil {
		return err
	}

	// Lifetime
	binary.Write(buf, binary.LittleEndian, m.Lifetime.Sec)
	binary.Write(buf, binary.LittleEndian, m.Lifetime.NSec)

	// Points
	binary.Write(buf, binary.LittleEndian, uint32(len(m.Points)))
	for _, e := range m.Points {
		if err = e.Serialize(buf); err != nil {
			return err
		}
	}

	// OutlineColors
	binary.Write(buf, binary.LittleEndian, uint32(len(m.OutlineColors)))
	for _, e := range m.OutlineColors {
		if err = e.Serialize(buf); err != nil {
			return err
		}
	}

	return
}

func (m *String) Deserialize(buf *bytes.Reader) (err error) {
	// Header
	if err = m.Header.Deserialize(buf); err != nil {
		return err
	}

	// Ns
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	data := make([]byte, int(size))
	if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
		return err
	}
	m.Ns = string(data)

	// ID
	if err = binary.Read(buf, binary.LittleEndian, &m.ID); err != nil {
		return err
	}

	// Type
	if err = binary.Read(buf, binary.LittleEndian, &m.Type); err != nil {
		return err
	}

	// Action
	if err = binary.Read(buf, binary.LittleEndian, &m.Action); err != nil {
		return err
	}

	// Position
	if err = m.Position.Deserialize(buf); err != nil {
		return err
	}

	// Scale
	if err = binary.Read(buf, binary.LittleEndian, &m.Scale); err != nil {
		return err
	}

	// OutlineColor
	if err = m.OutlineColor.Deserialize(buf); err != nil {
		return err
	}

	// Filled
	if err = binary.Read(buf, binary.LittleEndian, &m.Filled); err != nil {
		return err
	}

	// FillColor
	if err = m.FillColor.Deserialize(buf); err != nil {
		return err
	}

	// Lifetime
	if err = binary.Read(buf, binary.LittleEndian, &m.Lifetime.Sec); err != nil {
		return err
	}
	if err = binary.Read(buf, binary.LittleEndian, &m.Lifetime.NSec); err != nil {
		return err
	}

	// Points
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	m.Points = make([]geometry_msgs.Point, int(size))
	for i := 0; i < int(size); i++ {
		if err = m.Points[i].Deserialize(buf); err != nil {
			return err
		}
	}

	// OutlineColors
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	m.OutlineColors = make([]std_msgs.ColorRGBA, int(size))
	for i := 0; i < int(size); i++ {
		if err = m.OutlineColors[i].Deserialize(buf); err != nil {
			return err
		}
	}

	return
}
