// Code generated by ros-gen-go.
// source: /opt/ros/jade/share/ros/../visualization_msgs/msg//InteractiveMarkerControl.msg
// DO NOT EDIT!
package visualization_msgs

type _MsgInteractiveMarkerControl struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgInteractiveMarkerControl) Text() string {
	return t.text
}

func (t *_MsgInteractiveMarkerControl) Name() string {
	return t.name
}

func (t *_MsgInteractiveMarkerControl) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgInteractiveMarkerControl) NewMessage() ros.Message {
	m := new(InteractiveMarkerControl)

	return m
}

var (
	MsgInteractiveMarkerControl = &_MsgInteractiveMarkerControl{
		`# Represents a control that is to be displayed together with an interactive marker

# Identifying string for this control.
# You need to assign a unique value to this to receive feedback from the GUI
# on what actions the user performs on this control (e.g. a button click).
string name


# Defines the local coordinate frame (relative to the pose of the parent
# interactive marker) in which is being rotated and translated.
# Default: Identity
geometry_msgs/Quaternion orientation


# Orientation mode: controls how orientation changes.
# INHERIT: Follow orientation of interactive marker
# FIXED: Keep orientation fixed at initial state
# VIEW_FACING: Align y-z plane with screen (x: forward, y:left, z:up).
uint8 INHERIT = 0 
uint8 FIXED = 1
uint8 VIEW_FACING = 2

uint8 orientation_mode

# Interaction mode for this control
# 
# NONE: This control is only meant for visualization; no context menu.
# MENU: Like NONE, but right-click menu is active.
# BUTTON: Element can be left-clicked.
# MOVE_AXIS: Translate along local x-axis.
# MOVE_PLANE: Translate in local y-z plane.
# ROTATE_AXIS: Rotate around local x-axis.
# MOVE_ROTATE: Combines MOVE_PLANE and ROTATE_AXIS.
uint8 NONE = 0 
uint8 MENU = 1
uint8 BUTTON = 2
uint8 MOVE_AXIS = 3 
uint8 MOVE_PLANE = 4
uint8 ROTATE_AXIS = 5
uint8 MOVE_ROTATE = 6
# "3D" interaction modes work with the mouse+SHIFT+CTRL or with 3D cursors.
# MOVE_3D: Translate freely in 3D space.
# ROTATE_3D: Rotate freely in 3D space about the origin of parent frame.
# MOVE_ROTATE_3D: Full 6-DOF freedom of translation and rotation about the cursor origin.
uint8 MOVE_3D = 7
uint8 ROTATE_3D = 8
uint8 MOVE_ROTATE_3D = 9

uint8 interaction_mode


# If true, the contained markers will also be visible
# when the gui is not in interactive mode.
bool always_visible


# Markers to be displayed as custom visual representation.
# Leave this empty to use the default control handles.
#
# Note: 
# - The markers can be defined in an arbitrary coordinate frame,
#   but will be transformed into the local frame of the interactive marker.
# - If the header of a marker is empty, its pose will be interpreted as 
#   relative to the pose of the parent interactive marker.
Marker[] markers


# In VIEW_FACING mode, set this to true if you don't want the markers
# to be aligned with the camera view point. The markers will show up
# as in INHERIT mode.
bool independent_marker_orientation


# Short description (< 40 characters) of what this control does,
# e.g. "Move the robot". 
# Default: A generic description based on the interaction mode
string description
`,
		"visualization_msgs/InteractiveMarkerControl",
		"7111ea3d3e9c0ded6ccecb4dc9532391",
	}
)

type InteractiveMarkerControl struct {
	Name                         string
	Orientation                  geometry_msgs.Quaternion
	OrientationMode              uint8
	InteractionMode              uint8
	AlwaysVisible                bool
	Markers                      []Marker
	IndependentMarkerOrientation bool
	Description                  string
}

func (m *InteractiveMarkerControl) Type() ros.MessageType {
	return MsgInteractiveMarkerControl
}

func (m *InteractiveMarkerControl) Serialize(buf *bytes.Buffer) (err error) {
	// Name
	binary.Write(buf, binary.LittleEndian, uint32(len([]byte(m.Name))))
	buf.Write([]byte(m.Name))

	// Orientation
	if err = m.Orientation.Serialize(buf); err != nil {
		return err
	}

	// OrientationMode
	binary.Write(buf, binary.LittleEndian, m.OrientationMode)

	// InteractionMode
	binary.Write(buf, binary.LittleEndian, m.InteractionMode)

	// AlwaysVisible
	binary.Write(buf, binary.LittleEndian, m.AlwaysVisible)

	// Markers
	binary.Write(buf, binary.LittleEndian, uint32(len(m.Markers)))
	for _, e := range m.Markers {
		if err = e.Serialize(buf); err != nil {
			return err
		}
	}

	// IndependentMarkerOrientation
	binary.Write(buf, binary.LittleEndian, m.IndependentMarkerOrientation)

	// Description
	binary.Write(buf, binary.LittleEndian, uint32(len([]byte(m.Description))))
	buf.Write([]byte(m.Description))

	return
}

func (m *String) Deserialize(buf *bytes.Reader) (err error) {
	// Name
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	data := make([]byte, int(size))
	if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
		return err
	}
	m.Name = string(data)

	// Orientation
	if err = m.Orientation.Deserialize(buf); err != nil {
		return err
	}

	// OrientationMode
	if err = binary.Read(buf, binary.LittleEndian, &m.OrientationMode); err != nil {
		return err
	}

	// InteractionMode
	if err = binary.Read(buf, binary.LittleEndian, &m.InteractionMode); err != nil {
		return err
	}

	// AlwaysVisible
	if err = binary.Read(buf, binary.LittleEndian, &m.AlwaysVisible); err != nil {
		return err
	}

	// Markers
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	m.Markers = make([]Marker, int(size))
	for i := 0; i < int(size); i++ {
		if err = m.Markers[i].Deserialize(buf); err != nil {
			return err
		}
	}

	// IndependentMarkerOrientation
	if err = binary.Read(buf, binary.LittleEndian, &m.IndependentMarkerOrientation); err != nil {
		return err
	}

	// Description
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	data := make([]byte, int(size))
	if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
		return err
	}
	m.Description = string(data)

	return
}
