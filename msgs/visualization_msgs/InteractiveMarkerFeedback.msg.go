// Code generated by ros-gen-go.
// source: /opt/ros/jade/share/ros/../visualization_msgs/msg//InteractiveMarkerFeedback.msg
// DO NOT EDIT!
package visualization_msgs

type _MsgInteractiveMarkerFeedback struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgInteractiveMarkerFeedback) Text() string {
	return t.text
}

func (t *_MsgInteractiveMarkerFeedback) Name() string {
	return t.name
}

func (t *_MsgInteractiveMarkerFeedback) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgInteractiveMarkerFeedback) NewMessage() ros.Message {
	m := new(InteractiveMarkerFeedback)

	return m
}

var (
	MsgInteractiveMarkerFeedback = &_MsgInteractiveMarkerFeedback{
		`# Time/frame info.
Header header

# Identifying string. Must be unique in the topic namespace.
string client_id

# Feedback message sent back from the GUI, e.g.
# when the status of an interactive marker was modified by the user.

# Specifies which interactive marker and control this message refers to
string marker_name
string control_name

# Type of the event
# KEEP_ALIVE: sent while dragging to keep up control of the marker
# MENU_SELECT: a menu entry has been selected
# BUTTON_CLICK: a button control has been clicked
# POSE_UPDATE: the pose has been changed using one of the controls
uint8 KEEP_ALIVE = 0
uint8 POSE_UPDATE = 1
uint8 MENU_SELECT = 2
uint8 BUTTON_CLICK = 3

uint8 MOUSE_DOWN = 4
uint8 MOUSE_UP = 5

uint8 event_type

# Current pose of the marker
# Note: Has to be valid for all feedback types.
geometry_msgs/Pose pose

# Contains the ID of the selected menu entry
# Only valid for MENU_SELECT events.
uint32 menu_entry_id

# If event_type is BUTTON_CLICK, MOUSE_DOWN, or MOUSE_UP, mouse_point
# may contain the 3 dimensional position of the event on the
# control.  If it does, mouse_point_valid will be true.  mouse_point
# will be relative to the frame listed in the header.
geometry_msgs/Point mouse_point
bool mouse_point_valid
`,
		"visualization_msgs/InteractiveMarkerFeedback",
		"e3b3c21e428d08b74caa1bcb7dcc5413",
	}
)

type InteractiveMarkerFeedback struct {
	Header          Header
	ClientID        string
	MarkerName      string
	ControlName     string
	EventType       uint8
	Pose            geometry_msgs.Pose
	MenuEntryID     uint32
	MousePoint      geometry_msgs.Point
	MousePointValid bool
}

func (m *InteractiveMarkerFeedback) Type() ros.MessageType {
	return MsgInteractiveMarkerFeedback
}

func (m *InteractiveMarkerFeedback) Serialize(buf *bytes.Buffer) (err error) {
	// Header
	if err = m.Header.Serialize(buf); err != nil {
		return err
	}

	// ClientID
	binary.Write(buf, binary.LittleEndian, uint32(len([]byte(m.ClientID))))
	buf.Write([]byte(m.ClientID))

	// MarkerName
	binary.Write(buf, binary.LittleEndian, uint32(len([]byte(m.MarkerName))))
	buf.Write([]byte(m.MarkerName))

	// ControlName
	binary.Write(buf, binary.LittleEndian, uint32(len([]byte(m.ControlName))))
	buf.Write([]byte(m.ControlName))

	// EventType
	binary.Write(buf, binary.LittleEndian, m.EventType)

	// Pose
	if err = m.Pose.Serialize(buf); err != nil {
		return err
	}

	// MenuEntryID
	binary.Write(buf, binary.LittleEndian, m.MenuEntryID)

	// MousePoint
	if err = m.MousePoint.Serialize(buf); err != nil {
		return err
	}

	// MousePointValid
	binary.Write(buf, binary.LittleEndian, m.MousePointValid)

	return
}

func (m *String) Deserialize(buf *bytes.Reader) (err error) {
	// Header
	if err = m.Header.Deserialize(buf); err != nil {
		return err
	}

	// ClientID
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	data := make([]byte, int(size))
	if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
		return err
	}
	m.ClientID = string(data)

	// MarkerName
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	data := make([]byte, int(size))
	if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
		return err
	}
	m.MarkerName = string(data)

	// ControlName
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	data := make([]byte, int(size))
	if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
		return err
	}
	m.ControlName = string(data)

	// EventType
	if err = binary.Read(buf, binary.LittleEndian, &m.EventType); err != nil {
		return err
	}

	// Pose
	if err = m.Pose.Deserialize(buf); err != nil {
		return err
	}

	// MenuEntryID
	if err = binary.Read(buf, binary.LittleEndian, &m.MenuEntryID); err != nil {
		return err
	}

	// MousePoint
	if err = m.MousePoint.Deserialize(buf); err != nil {
		return err
	}

	// MousePointValid
	if err = binary.Read(buf, binary.LittleEndian, &m.MousePointValid); err != nil {
		return err
	}

	return
}
