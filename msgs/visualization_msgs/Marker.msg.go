// Code generated by ros-gen-go.
// source: /opt/ros/jade/share/ros/../visualization_msgs/msg//Marker.msg
// DO NOT EDIT!
package visualization_msgs

type _MsgMarker struct {
	text   string
	name   string
	md5sum string
}

func (t *_MsgMarker) Text() string {
	return t.text
}

func (t *_MsgMarker) Name() string {
	return t.name
}

func (t *_MsgMarker) MD5Sum() string {
	return t.md5sum
}

func (t *_MsgMarker) NewMessage() ros.Message {
	m := new(Marker)

	return m
}

var (
	MsgMarker = &_MsgMarker{
		`# See http://www.ros.org/wiki/rviz/DisplayTypes/Marker and http://www.ros.org/wiki/rviz/Tutorials/Markers%3A%20Basic%20Shapes for more information on using this message with rviz

uint8 ARROW=0
uint8 CUBE=1
uint8 SPHERE=2
uint8 CYLINDER=3
uint8 LINE_STRIP=4
uint8 LINE_LIST=5
uint8 CUBE_LIST=6
uint8 SPHERE_LIST=7
uint8 POINTS=8
uint8 TEXT_VIEW_FACING=9
uint8 MESH_RESOURCE=10
uint8 TRIANGLE_LIST=11

uint8 ADD=0
uint8 MODIFY=0
uint8 DELETE=2
uint8 DELETEALL=3

Header header                        # header for time/frame information
string ns                            # Namespace to place this object in... used in conjunction with id to create a unique name for the object
int32 id 		                         # object ID useful in conjunction with the namespace for manipulating and deleting the object later
int32 type 		                       # Type of object
int32 action 	                       # 0 add/modify an object, 1 (deprecated), 2 deletes an object, 3 deletes all objects
geometry_msgs/Pose pose                 # Pose of the object
geometry_msgs/Vector3 scale             # Scale of the object 1,1,1 means default (usually 1 meter square)
std_msgs/ColorRGBA color             # Color [0.0-1.0]
duration lifetime                    # How long the object should last before being automatically deleted.  0 means forever
bool frame_locked                    # If this marker should be frame-locked, i.e. retransformed into its frame every timestep

#Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, ...)
geometry_msgs/Point[] points
#Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, ...)
#number of colors must either be 0 or equal to the number of points
#NOTE: alpha is not yet used
std_msgs/ColorRGBA[] colors

# NOTE: only used for text markers
string text

# NOTE: only used for MESH_RESOURCE markers
string mesh_resource
bool mesh_use_embedded_materials
`,
		"visualization_msgs/Marker",
		"06f252f28e50b583ca77b8a19201f579",
	}
)

type Marker struct {
	Header                   Header
	Ns                       string
	ID                       int32
	Type                     int32
	Action                   int32
	Pose                     geometry_msgs.Pose
	Scale                    geometry_msgs.Vector3
	Color                    std_msgs.ColorRGBA
	Lifetime                 ros.Duration
	FrameLocked              bool
	Points                   []geometry_msgs.Point
	Colors                   []std_msgs.ColorRGBA
	Text                     string
	MeshResource             string
	MeshUseEmbeddedMaterials bool
}

func (m *Marker) Type() ros.MessageType {
	return MsgMarker
}

func (m *Marker) Serialize(buf *bytes.Buffer) (err error) {
	// Header
	if err = m.Header.Serialize(buf); err != nil {
		return err
	}

	// Ns
	binary.Write(buf, binary.LittleEndian, uint32(len([]byte(m.Ns))))
	buf.Write([]byte(m.Ns))

	// ID
	binary.Write(buf, binary.LittleEndian, m.ID)

	// Type
	binary.Write(buf, binary.LittleEndian, m.Type)

	// Action
	binary.Write(buf, binary.LittleEndian, m.Action)

	// Pose
	if err = m.Pose.Serialize(buf); err != nil {
		return err
	}

	// Scale
	if err = m.Scale.Serialize(buf); err != nil {
		return err
	}

	// Color
	if err = m.Color.Serialize(buf); err != nil {
		return err
	}

	// Lifetime
	binary.Write(buf, binary.LittleEndian, m.Lifetime.Sec)
	binary.Write(buf, binary.LittleEndian, m.Lifetime.NSec)

	// FrameLocked
	binary.Write(buf, binary.LittleEndian, m.FrameLocked)

	// Points
	binary.Write(buf, binary.LittleEndian, uint32(len(m.Points)))
	for _, e := range m.Points {
		if err = e.Serialize(buf); err != nil {
			return err
		}
	}

	// Colors
	binary.Write(buf, binary.LittleEndian, uint32(len(m.Colors)))
	for _, e := range m.Colors {
		if err = e.Serialize(buf); err != nil {
			return err
		}
	}

	// Text
	binary.Write(buf, binary.LittleEndian, uint32(len([]byte(m.Text))))
	buf.Write([]byte(m.Text))

	// MeshResource
	binary.Write(buf, binary.LittleEndian, uint32(len([]byte(m.MeshResource))))
	buf.Write([]byte(m.MeshResource))

	// MeshUseEmbeddedMaterials
	binary.Write(buf, binary.LittleEndian, m.MeshUseEmbeddedMaterials)

	return
}

func (m *String) Deserialize(buf *bytes.Reader) (err error) {
	// Header
	if err = m.Header.Deserialize(buf); err != nil {
		return err
	}

	// Ns
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	data := make([]byte, int(size))
	if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
		return err
	}
	m.Ns = string(data)

	// ID
	if err = binary.Read(buf, binary.LittleEndian, &m.ID); err != nil {
		return err
	}

	// Type
	if err = binary.Read(buf, binary.LittleEndian, &m.Type); err != nil {
		return err
	}

	// Action
	if err = binary.Read(buf, binary.LittleEndian, &m.Action); err != nil {
		return err
	}

	// Pose
	if err = m.Pose.Deserialize(buf); err != nil {
		return err
	}

	// Scale
	if err = m.Scale.Deserialize(buf); err != nil {
		return err
	}

	// Color
	if err = m.Color.Deserialize(buf); err != nil {
		return err
	}

	// Lifetime
	if err = binary.Read(buf, binary.LittleEndian, &m.Lifetime.Sec); err != nil {
		return err
	}
	if err = binary.Read(buf, binary.LittleEndian, &m.Lifetime.NSec); err != nil {
		return err
	}

	// FrameLocked
	if err = binary.Read(buf, binary.LittleEndian, &m.FrameLocked); err != nil {
		return err
	}

	// Points
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	m.Points = make([]geometry_msgs.Point, int(size))
	for i := 0; i < int(size); i++ {
		if err = m.Points[i].Deserialize(buf); err != nil {
			return err
		}
	}

	// Colors
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	m.Colors = make([]std_msgs.ColorRGBA, int(size))
	for i := 0; i < int(size); i++ {
		if err = m.Colors[i].Deserialize(buf); err != nil {
			return err
		}
	}

	// Text
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	data := make([]byte, int(size))
	if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
		return err
	}
	m.Text = string(data)

	// MeshResource
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	data := make([]byte, int(size))
	if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
		return err
	}
	m.MeshResource = string(data)

	// MeshUseEmbeddedMaterials
	if err = binary.Read(buf, binary.LittleEndian, &m.MeshUseEmbeddedMaterials); err != nil {
		return err
	}

	return
}
