// Code generated by ros-gen-go.
// source: {{ .InFile }}
// DO NOT EDIT!
package {{ .PackageName }}

type _Msg{{ .Name }} struct {
	text string
	name string
	md5sum string
}

func (t *_Msg{{ .Name }}) Text() string {
	return t.text
}

func (t *_Msg{{ .Name }}) Name() string {
	return t.name
}

func (t *_Msg{{ .Name }}) MD5Sum() string {
	return t.md5sum
}

func (t *_Msg{{ .Name }}) NewMessage() ros.Message {
	m := new({{ .Name }})
	{{/* NOTE: No need to initialize fields as they are all zero value, which is default in go */}}
	return m
}

var (
	Msg{{ .Name }} = &_Msg{{ .Name }} {
		`{{ .Raw }}`,
		"{{ .PackageName }}/{{ .Name }}",
		"{{ .MD5Sum }}",
	}
)

type {{ .Name }} struct {
	{{- range .Fields }}
	{{ .Name }} {{ if .IsArray }}[{{ if gt .ArraySize 0 }}{{ .ArraySize }}{{ end }}]{{ end }}{{ .GoTypeName }}
	{{- end }}
}

func (m *{{ .Name }}) Type() ros.MessageType {
	return Msg{{ .Name }}
}

{{- define "serialize" }}
	{{- if .BuiltIn }}
	{{- if eq .TypeName "string" }}
	binary.Write(buf, binary.LittleEndian, uint32(len([]byte({{ .LoopVar }}))))
	buf.Write([]byte({{ .LoopVar }}))

	{{- else if eq .TypeName "time" "duration" }}
	binary.Write(buf, binary.LittleEndian, {{ .LoopVar }}.Sec)
	binary.Write(buf, binary.LittleEndian, {{ .LoopVar }}.NSec)

	{{- else }}
	binary.Write(buf, binary.LittleEndian, {{ .LoopVar }})

	{{- end }}
	{{- else }}
	if err = {{ .LoopVar }}.Serialize(buf); err != nil {
		return err
	}
	{{- end }}
{{- end }}

func (m *{{ .Name }}) Serialize(buf *bytes.Buffer) (err error) {
	{{- range .Fields }}
	// {{ .Name }}
	{{- if .IsArray }}
	binary.Write(buf, binary.LittleEndian, uint32(len(m.{{ .Name }})))
	for _, e := range m.{{ .Name }} {
		{{- template "serialize" setloopvar . "e" }}
	}
	{{- else }}
	{{- template "serialize" setloopvar . (printf "m.%s" .Name) }}
	{{- end }}
	{{ end }}
	return
}

{{- define "deserialize" }}
	{{- if .BuiltIn }}
	{{- if eq .TypeName "string" }}
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	data := make([]byte, int(size))
	if err = binary.Read(buf, binary.LittleEndian, data); err != nil {
		return err
	}
	{{ .LoopVar }} = string(data)

	{{- else if eq .TypeName "time" "duration" }}
	if err = binary.Read(buf, binary.LittleEndian, &{{ .LoopVar }}.Sec); err != nil {
		return err
	}
	if err = binary.Read(buf, binary.LittleEndian, &{{ .LoopVar }}.NSec); err != nil {
		return err
	}

	{{- else }}
	if err = binary.Read(buf, binary.LittleEndian, &{{ .LoopVar }}); err != nil {
		return err
	}

	{{- end }}
	{{- else }}
	if err = {{ .LoopVar }}.Deserialize(buf); err != nil {
		return err
	}
	{{- end }}
{{- end }}

func (m *String) Deserialize(buf *bytes.Reader) (err error) {
	{{- range .Fields }}
	// {{ .Name }}
	{{- if .IsArray }}
	var size uint32
	if err = binary.Read(buf, binary.LittleEndian, &size); err != nil {
		return err
	}
	{{- if gt .ArraySize 0 }}
	if size > {{ .ArraySize }} {
	  return fmt.Errorf("array size for {{ .Name }} too large: expected={{ .ArraySize }}, got=%d", size)
	}
	{{- else }}
	m.{{ .Name }} = make([]{{ .GoTypeName }}, int(size))
	{{- end }}
	for i := 0; i < int(size); i++ {
		{{- template "deserialize" setloopvar . (printf "m.%s[i]" .Name) }}
	}
	{{- else }}
	{{- template "deserialize" setloopvar . (printf "m.%s" .Name) }}
	{{- end }}
	{{ end }}
	return
}
